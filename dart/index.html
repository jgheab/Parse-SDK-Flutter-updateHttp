<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
  <meta name="generator" content="made with love by dartdoc 6.2.2">
  <meta name="description" content="parse_server_sdk API docs, for the Dart programming language.">
  <title>parse_server_sdk - Dart API docs</title>


  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" rel="stylesheet">
  
  <link rel="stylesheet" href="static-assets/github.css?v1">
  <link rel="stylesheet" href="static-assets/styles.css?v1">
  <link rel="icon" href="static-assets/favicon.png?v1">

  
</head>


<body data-base-href="" data-using-base-href="false" class="light-theme">

<div id="overlay-under-drawer"></div>

<header id="title">
  <span id="sidenav-left-toggle" class="material-symbols-outlined" role="button" tabindex="0">menu</span>
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li><a href="https://github.com/parse-community/Parse-SDK-Flutter">parse_server_sdk package</a></li>
  </ol>
  <div class="self-name">parse_server_sdk</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
  <div class="toggle" id="theme-button">
    <label for="theme">
      <input type="checkbox" id="theme" value="light-theme">
      <span id="dark-theme-button" class="material-symbols-outlined">
        brightness_4
      </span>
      <span id="light-theme-button" class="material-symbols-outlined">
        brightness_5
      </span>
    </label>
  </div>
</header>
<main>

  <div id="dartdoc-main-content" class="main-content">
      
<section class="desc markdown">
  <p><img src="https://user-images.githubusercontent.com/5673677/166120960-ea1f58e3-a62b-4770-b541-f64186859339.png" alt="parse-repository-header-sdk-dart"></p>
<hr>
<p>This library gives you access to the powerful Parse Server backend from your Dart app. For more information on Parse Platform and its features, visit <a href="https://parseplatform.org">parseplatform.org</a>. The Flutter package was moved <a href="https://pub.dev/packages/parse_server_sdk_flutter">here</a>. If you are using Flutter see <a href="https://github.com/parse-community/Parse-SDK-Flutter/blob/release/2.0.0/docs/migrate-2-0-0.md">this guide</a> for how to migrate.</p>
<hr>
<ul>
<li><a href="#compatibility">Compatibility</a></li>
<li><a href="#getting-started">Getting Started</a>
<ul>
<li><a href="#early-web-support">Early Web support</a></li>
</ul>
</li>
<li><a href="#objects">Objects</a></li>
<li><a href="#custom-objects">Custom Objects</a></li>
<li><a href="#add-new-values-to-objects">Add New Values to Objects</a></li>
<li><a href="#save-objects-using-pins">Save Objects using Pins</a></li>
<li><a href="#storage">Storage</a></li>
<li><a href="#increment-counter-values">Increment Counter Values</a></li>
<li><a href="#array-operator-in-objects">Array Operator in Objects</a></li>
<li><a href="#queries">Queries</a>
<ul>
<li><a href="#alternative-query-methods">Alternative Query Methods</a></li>
</ul>
</li>
<li><a href="#complex-queries">Complex Queries</a></li>
<li><a href="#relational-queries">Relational queries</a></li>
<li><a href="#counting-objects">Counting objects</a></li>
<li><a href="#livequery">LiveQuery</a></li>
<li><a href="#parselivelist">ParseLiveList</a>
<ul>
<li><a href="#general-use">General Use</a></li>
<li><a href="#included-sub-objects">Included Sub-Objects</a></li>
</ul>
</li>
<li><a href="#users">Users</a></li>
<li><a href="#facebook-oauth-and-3rd-party-loginuser">Facebook, OAuth and 3rd Party Login/User</a></li>
<li><a href="#security-for-objects---parseacl">Security for Objects - ParseACL</a></li>
<li><a href="#config">Config</a></li>
<li><a href="#cloud-functions">Cloud Functions</a></li>
<li><a href="#relation">Relation</a></li>
<li><a href="#file">File</a></li>
<li><a href="#other-features">Other Features</a></li>
</ul>
<hr>
<h2 id="compatibility">Compatibility</h2>
<p>The Parse Dart SDK is continuously tested with the most recent release of the Dart framework to ensure compatibility. To give developers time to upgrade their app to the newest Dart framework, previous Dart framework releases are supported for at least 1 year after their <a href="https://dart.dev/get-dart/archive">release date</a>.</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Latest Version</th>
<th>End of Support</th>
<th>Compatible</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dart 3.0</td>
<td>3.0.0</td>
<td>May 2024</td>
<td>✅ Yes</td>
</tr>
<tr>
<td>Dart 2.19</td>
<td>2.19.6</td>
<td>Mar 2024</td>
<td>✅ Yes</td>
</tr>
<tr>
<td>Dart 2.18</td>
<td>2.18.7</td>
<td>Jan 2024</td>
<td>✅ Yes</td>
</tr>
<tr>
<td>Dart 2.17</td>
<td>2.17.7</td>
<td>Aug 2023</td>
<td>❌ No (Parse Dart SDK requires Dart &gt;=2.18.0)</td>
</tr>
</tbody>
</table>
<h2 id="getting-started">Getting Started</h2>
<p>To install, either add <a href="https://pub.dev/packages/parse_server_sdk/install">dependency in your pubspec.yaml file</a>.</p>
<p>Once you have the library added to your project, upon first call to your app (Similar to what your application class would be) add the following...</p>
<pre class="language-dart"><code class="language-dart">await Parse().initialize(
        keyApplicationId,
        keyParseServerUrl,
        );
</code></pre>
<p>If you want to use secure storage or use the Flutter web/desktop SDK, please change to the below instance of CoreStorage as it has no dependencies on Flutter.</p>
<p><strong>The <code>CoreStoreSembastImp</code> does not encrypt the data on web!</strong> (Web is not safe anyway. Encrypt fields manually as needed.)</p>
<pre class="language-dart"><code class="language-dart">
await Parse().initialize(
  	keyParseApplicationId, 
  	keyParseServerUrl,
    coreStore: await CoreStoreSembastImp.getInstance("/data"));
</code></pre>
<p>It's possible to add other parameters to work with your instance of Parse Server:-</p>
<pre class="language-dart"><code class="language-dart">  await Parse().initialize(
        keyApplicationId,
        keyParseServerUrl,
        clientKey: keyParseClientKey, // Required for some setups
        debug: true, // When enabled, prints logs to console
        liveQueryUrl: keyLiveQueryUrl, // Required if using LiveQuery 
        autoSendSessionId: true, // Required for authentication and ACL
        securityContext: securityContext, // Again, required for some setups
	coreStore: CoreStoreMemoryImp()); // Non persistent mode (default): Sdk will store everything in memmore instead of using Sembast as an internal DB.
</code></pre>
<p>⚠️ Please note that the master key should only be used in safe environments and never on client side ‼️ Using this package on a server should be fine.</p>
<h4 id="early-web-support">Early Web support</h4>
<p>Currently this requires adding <code>X-Parse-Installation-Id</code> as an allowed header to parse-server.
When running directly via docker, set the env var <code>PARSE_SERVER_ALLOW_HEADERS=X-Parse-Installation-Id</code>.
When running via express, set <a href="https://parseplatform.org/parse-server/api/master/ParseServerOptions.html">ParseServerOptions</a> <code>allowHeaders: ['X-Parse-Installation-Id']</code>.</p>
<p>Be aware that for web ParseInstallation does include app name, version or package identifier.</p>
<h2 id="objects">Objects</h2>
<p>You can create custom objects by calling:</p>
<pre class="language-dart"><code class="language-dart">var dietPlan = ParseObject('DietPlan')
	..set('Name', 'Ketogenic')
	..set('Fat', 65);
await dietPlan.save();
</code></pre>
<p>Or update existing object by its objectId by calling:</p>
<pre class="language-dart"><code class="language-dart">var dietPlan = ParseObject('DietPlan')
	..objectId = 'R5EonpUDWy'
	..set('Fat', 70);
await dietPlan.save();
</code></pre>
<p>Verify that the object has been successfully saved using</p>
<pre class="language-dart"><code class="language-dart">var response = await dietPlan.save();
if (response.success) {
   dietPlan = response.results.first;
}
</code></pre>
<p>Types supported:</p>
<ul>
<li>String</li>
<li>Double</li>
<li>Int</li>
<li>Boolean</li>
<li>DateTime</li>
<li>File</li>
<li>Geopoint</li>
<li>ParseObject/ParseUser (Pointer)</li>
<li>Map</li>
<li>List (all types supported)</li>
</ul>
<p>You then have the ability to do the following with that object:
The features available are:-</p>
<ul>
<li>Get</li>
<li>GetAll</li>
<li>Create</li>
<li>Save</li>
<li>Query - By object Id</li>
<li>Delete</li>
<li>Complex queries as shown above</li>
<li>Pin</li>
<li>Plenty more</li>
<li>Counters</li>
<li>Array Operators</li>
</ul>
<h2 id="custom-objects">Custom Objects</h2>
<p>You can create your own <code>ParseObjects</code> or convert your existing objects into Parse Objects by doing the following:</p>
<pre class="language-dart"><code class="language-dart">class DietPlan extends ParseObject implements ParseCloneable {

  DietPlan() : super(_keyTableName);
  DietPlan.clone(): this();

  /// Looks strangely hacky but due to Flutter not using reflection, we have to
  /// mimic a clone
  @override clone(Map map) =&gt; DietPlan.clone()..fromJson(map);

  static const String _keyTableName = 'Diet_Plans';
  static const String keyName = 'Name';
  
  String get name =&gt; get&lt;String&gt;(keyName);
  set name(String name) =&gt; set&lt;String&gt;(keyName, name);
}
  
</code></pre>
<p>When receiving an <code>ParseObject</code> from the SDK, you can often provide an instance of your custom object as an copy object.
To always use your custom object class, you can register your subclass at the initialization of the SDK.</p>
<pre class="language-dart"><code class="language-dart">Parse().initialize(
   ...,
   registeredSubClassMap: &lt;String, ParseObjectConstructor&gt;{
     'Diet_Plans': () =&gt; DietPlan(),
   },
   parseUserConstructor: (username, password, emailAddress, {client, debug, sessionToken}) =&gt; CustomParseUser(username, password, emailAddress),
);
</code></pre>
<p>Additionally you can register <code>SubClasses</code> after the initialization of the SDK.</p>
<pre class="language-dart"><code class="language-dart">ParseCoreData().registerSubClass('Diet_Plans', () =&gt; DietPlan());
ParseCoreData().registerUserSubClass((username, password, emailAddress, {client, debug, sessionToken}) =&gt; CustomParseUser(username, password, emailAddress));
</code></pre>
<p>Providing a <code>ParseObject</code> as described above should still work, even if you have registered a different <code>SubClass</code>.</p>
<p>For custom file classes have a lock at <a href="#File">here</a>.</p>
<h2 id="add-new-values-to-objects">Add New Values to Objects</h2>
<p>To add a variable to an object call and retrieve it, call</p>
<pre class="language-dart"><code class="language-dart">dietPlan.set&lt;int&gt;('RandomInt', 8);
var randomInt = dietPlan.get&lt;int&gt;('RandomInt');
</code></pre>
<h2 id="save-objects-using-pins">Save Objects using Pins</h2>
<p>You can now save an object by calling <code>.pin()</code> on an instance of an object</p>
<pre class="language-dart"><code class="language-dart">dietPlan.pin();
</code></pre>
<p>and to retrieve it</p>
<pre class="language-dart"><code class="language-dart">var dietPlan = DietPlan().fromPin('OBJECT ID OF OBJECT');
</code></pre>
<h2 id="storage">Storage</h2>
<p>We now have 2 types of storage, secure and unsecure. We currently rely on 2 third party options:</p>
<ul>
<li>SharedPreferences</li>
<li>Sembast
Sembast offers secured storage, whilst SharePreferences wraps NSUserDefaults (on iOS) and SharedPreferences (on Android).</li>
</ul>
<p>The storage method is defined in the parameter <strong>coreStore</strong> in  Parse().initialize</p>
<p>Check sample code for options</p>
<h2 id="increment-counter-values">Increment Counter Values</h2>
<p>Retrieve it, call</p>
<pre class="language-dart"><code class="language-dart">var response = await dietPlan.increment("count", 1);

</code></pre>
<p>or using with save function</p>
<pre class="language-dart"><code class="language-dart">dietPlan.setIncrement('count', 1);
dietPlan.setDecrement('count', 1);
var response = dietPlan.save()

</code></pre>
<h2 id="array-operator-in-objects">Array Operator in Objects</h2>
<p>Retrieve it, call</p>
<pre class="language-dart"><code class="language-dart">var response = await dietPlan.add("listKeywords", ["a", "a","d"]);

var response = await dietPlan.addUnique("listKeywords", ["a", "a","d"]);

var response = await dietPlan.remove("listKeywords", ["a"]);

</code></pre>
<p>or using with save function</p>
<pre class="language-dart"><code class="language-dart">dietPlan.setAdd('listKeywords', ['a','a','d']);
dietPlan.setAddUnique('listKeywords', ['a','a','d']);
dietPlan.setRemove('listKeywords', ['a']);
var response = dietPlan.save()
</code></pre>
<h2 id="queries">Queries</h2>
<p>Once you have setup the project and initialised the instance, you can then retreive data from your server by calling:</p>
<pre class="language-dart"><code class="language-dart">var apiResponse = await ParseObject('ParseTableName').getAll();

if (apiResponse.success){
  for (var testObject in apiResponse.result) {
    print(ApplicationConstants.APP_NAME + ": " + testObject.toString());
  }
}
</code></pre>
<p>Or you can get an object by its objectId:</p>
<pre class="language-dart"><code class="language-dart">var dietPlan = await DietPlan().getObject('R5EonpUDWy');

if (dietPlan.success) {
  print(ApplicationConstants.keyAppName + ": " + (dietPlan.result as DietPlan).toString());
} else {
  print(ApplicationConstants.keyAppName + ": " + dietPlan.exception.message);
}
</code></pre>
<h3 id="alternative-query-methods">Alternative Query Methods</h3>
<p>The standard query method <code>query()</code> returns a <code>ParseResponse</code> that contains the result or the error. As an alternative, you can also use <code>Future&lt;List&lt;T&gt;&gt; find()</code> for receiving options.
This method returns an <code>Future</code> that either resolves in an error (equivalent of the error in the <code>ParseResponse</code>) or an <code>List</code> containing the queried objects. One difference, you should be aware of, is the fact, that <code>Future&lt;List&lt;T&gt;&gt; find()</code> will return an empty list instead of the 'No results' error you receive in case no object matches you query.</p>
<p>Choosing between <code>query()</code> and <code>find()</code> comes down to personal preference. Both methods can be used for querying a <code>ParseQuery</code>, just the output method differs.</p>
<p>Similar to <code>find()</code> the <code>QueryBuilder</code> also has a function called <code>Future&lt;T?&gt; first()</code>. Just like <code>find()</code> <code>first()</code> is just a convenience method that makes querying the first object satisfying the query simpler. <code>first()</code> returns an <code>Future</code>, that resoles in an error or the first object matching the query. In case no object satisfies the query, the result will be <code>null</code>.</p>
<h2 id="complex-queries">Complex Queries</h2>
<p>You can create complex queries to really put your database to the test:</p>
<pre class="language-dart"><code class="language-dart">var queryBuilder = QueryBuilder&lt;DietPlan&gt;(DietPlan())
  ..startsWith(DietPlan.keyName, "Keto")
  ..greaterThan(DietPlan.keyFat, 64)
  ..lessThan(DietPlan.keyFat, 66)
  ..equals(DietPlan.keyCarbs, 5);

var response = await queryBuilder.query();

if (response.success) {
  print(ApplicationConstants.keyAppName + ": " + ((response.results as List&lt;dynamic&gt;).first as DietPlan).toString());
} else {
  print(ApplicationConstants.keyAppName + ": " + response.exception.message);
}
</code></pre>
<p>if you want to find objects that match one of several queries, you can use <strong>QueryBuilder.or</strong> method to construct a query that is an OR of the queries passed in. For instance if you want to find players who either have a lot of wins or a few wins, you can do:</p>
<pre class="language-dart"><code class="language-dart">ParseObject playerObject = ParseObject("Player");

QueryBuilder&lt;ParseObject&gt; lotsOfWins =
    QueryBuilder&lt;ParseObject&gt;(playerObject))
      ..whereGreaterThan('wins', 50);

QueryBuilder&lt;ParseObject&gt; fewWins =
    QueryBuilder&lt;ParseObject&gt;(playerObject)
      ..whereLessThan('wins', 5);

QueryBuilder&lt;ParseObject&gt; mainQuery = QueryBuilder.or(
      playerObject,
      [lotsOfWins, fewWins],
    );

var apiResponse = await mainQuery.query();
</code></pre>
<p>To find objects that match several queries use <strong>QueryBuilder.and</strong>. To find objects that do not match any given query use <strong>QueryBuilder.nor</strong>.</p>
<p>The features available are:-</p>
<ul>
<li>Equals</li>
<li>Contains</li>
<li>LessThan</li>
<li>LessThanOrEqualTo</li>
<li>GreaterThan</li>
<li>GreaterThanOrEqualTo</li>
<li>NotEqualTo</li>
<li>StartsWith</li>
<li>EndsWith</li>
<li>Exists</li>
<li>Near</li>
<li>WithinMiles</li>
<li>WithinKilometers</li>
<li>WithinRadians</li>
<li>WithinGeoBox</li>
<li>WithinPolygon</li>
<li>MatchesQuery</li>
<li>DoesNotMatchQuery</li>
<li>MatchesKeyInQuery</li>
<li>DoesNotMatchKeyInQuery</li>
<li>Regex</li>
<li>Order</li>
<li>Limit</li>
<li>Skip</li>
<li>Ascending</li>
<li>Descending</li>
<li>Plenty more!</li>
</ul>
<h2 id="relational-queries">Relational queries</h2>
<p>If you want to retrieve objects where a field contains an object that matches another query, you can use the
<strong>whereMatchesQuery</strong> condition.
For example, imagine you have Post class and a Comment class, where each Comment has a pointer to its parent Post.
You can find comments on posts with images by doing:</p>
<pre class="language-dart"><code class="language-dart">QueryBuilder&lt;ParseObject&gt; queryPost =
    QueryBuilder&lt;ParseObject&gt;(ParseObject('Post'))
      ..whereValueExists('image', true);

QueryBuilder&lt;ParseObject&gt; queryComment =
    QueryBuilder&lt;ParseObject&gt;(ParseObject('Comment'))
      ..whereMatchesQuery('post', queryPost);

var apiResponse = await queryComment.query();
</code></pre>
<p>If you want to retrieve objects where a field contains an object that does not match another query,  you can use the
<strong>whereDoesNotMatchQuery</strong> condition.
Imagine you have Post class and a Comment class, where each Comment has a pointer to its parent Post.
You can find comments on posts without images by doing:</p>
<pre class="language-dart"><code class="language-dart">QueryBuilder&lt;ParseObject&gt; queryPost =
    QueryBuilder&lt;ParseObject&gt;(ParseObject('Post'))
      ..whereValueExists('image', true);

QueryBuilder&lt;ParseObject&gt; queryComment =
    QueryBuilder&lt;ParseObject&gt;(ParseObject('Comment'))
      ..whereDoesNotMatchQuery('post', queryPost);

var apiResponse = await queryComment.query();
</code></pre>
<p>You can use the <strong>whereMatchesKeyInQuery</strong> method to get objects where a key matches the value of a key in a set of objects resulting from another query. For example, if you have a class containing sports teams and you store a user’s hometown in the user class, you can issue one query to find the list of users whose hometown teams have winning records. The query would look like::</p>
<pre class="language-dart"><code class="language-dart">QueryBuilder&lt;ParseObject&gt; teamQuery =
    QueryBuilder&lt;ParseObject&gt;(ParseObject('Team'))
      ..whereGreaterThan('winPct', 0.5);

QueryBuilder&lt;ParseUser&gt; userQuery =
    QueryBuilder&lt;ParseUser&gt;ParseUser.forQuery())
      ..whereMatchesKeyInQuery('hometown', 'city', teamQuery);

var apiResponse = await userQuery.query();
</code></pre>
<p>Conversely, to get objects where a key does not match the value of a key in a set of objects resulting from another query, use <strong>whereDoesNotMatchKeyInQuery</strong>. For example, to find users whose hometown teams have losing records:</p>
<pre class="language-dart"><code class="language-dart">QueryBuilder&lt;ParseObject&gt; teamQuery =
    QueryBuilder&lt;ParseObject&gt;(ParseObject('Team'))
      ..whereGreaterThan('winPct', 0.5);

QueryBuilder&lt;ParseUser&gt; losingUserQuery =
    QueryBuilder&lt;ParseUser&gt;ParseUser.forQuery())
      ..whereDoesNotMatchKeyInQuery('hometown', 'city', teamQuery);

var apiResponse = await losingUserQuery.query();
</code></pre>
<p>To filter rows based on objectId’s from pointers in a second table, you can use dot notation:</p>
<pre class="language-dart"><code class="language-dart">QueryBuilder&lt;ParseObject&gt; rolesOfTypeX =
    QueryBuilder&lt;ParseObject&gt;(ParseObject('Role'))
      ..whereEqualTo('type', 'x');

QueryBuilder&lt;ParseObject&gt; groupsWithRoleX =
    QueryBuilder&lt;ParseObject&gt;(ParseObject('Group')))
      ..whereMatchesKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);

var apiResponse = await groupsWithRoleX.query();
</code></pre>
<h2 id="counting-objects">Counting objects</h2>
<p>If you only care about the number of games played by a particular player:</p>
<pre class="language-dart"><code class="language-dart">QueryBuilder&lt;ParseObject&gt; queryPlayers =
    QueryBuilder&lt;ParseObject&gt;(ParseObject('GameScore'))
      ..whereEqualTo('playerName', 'Jonathan Walsh');
var apiResponse = await queryPlayers.count();
if (apiResponse.success &amp;&amp; apiResponse.result != null) {
  int countGames = apiResponse.count;
}
</code></pre>
<h2 id="livequery">LiveQuery</h2>
<p>This tool allows you to subscribe to a QueryBuilder you are interested in. Once subscribed, the server will notify clients
whenever a ParseObject that matches the QueryBuilder is created or updated, in real-time.</p>
<p>Parse LiveQuery contains two parts, the LiveQuery server and the LiveQuery clients. In order to use live queries, you need
to set up both of them.</p>
<p>The Parse Server configuration guide on the server is found here <a href="https://docs.parseplatform.org/parse-server/guide/#live-queries">https://docs.parseplatform.org/parse-server/guide/#live-queries</a> and is not part of this documentation.</p>
<p>Initialize the Parse Live Query by entering the parameter liveQueryUrl in Parse().initialize:</p>
<pre class="language-dart"><code class="language-dart">Parse().initialize(
      keyApplicationId,
      keyParseServerUrl,
      clientKey: keyParseClientKey,
      debug: true,
      liveQueryUrl: keyLiveQueryUrl,
      autoSendSessionId: true);
</code></pre>
<p>Declare LiveQuery:</p>
<pre class="language-dart"><code class="language-dart">final LiveQuery liveQuery = LiveQuery();
</code></pre>
<p>Set the QueryBuilder that will be monitored by LiveQuery:</p>
<pre class="language-dart"><code class="language-dart">QueryBuilder&lt;ParseObject&gt; query =
  QueryBuilder&lt;ParseObject&gt;(ParseObject('TestAPI'))
  ..whereEqualTo('intNumber', 1);
</code></pre>
<p><strong>Create a subscription</strong>
You’ll get the LiveQuery events through this subscription.
The first time you call subscribe, we’ll try to open the WebSocket connection to the LiveQuery server for you.</p>
<pre class="language-dart"><code class="language-dart">Subscription subscription = await liveQuery.client.subscribe(query);
</code></pre>
<p><strong>Event Handling</strong>
We define several types of events you’ll get through a subscription object:</p>
<p><strong>Create event</strong>
When a new ParseObject is created and it fulfills the QueryBuilder you subscribe, you’ll get this event.
The object is the ParseObject which was created.</p>
<pre class="language-dart"><code class="language-dart">subscription.on(LiveQueryEvent.create, (value) {
    print('*** CREATE ***: ${DateTime.now().toString()}\n $value ');
    print((value as ParseObject).objectId);
    print((value as ParseObject).updatedAt);
    print((value as ParseObject).createdAt);
    print((value as ParseObject).get('objectId'));
    print((value as ParseObject).get('updatedAt'));
    print((value as ParseObject).get('createdAt'));
});
</code></pre>
<p><strong>Update event</strong>
When an existing ParseObject which fulfills the QueryBuilder you subscribe is updated (The ParseObject fulfills the
QueryBuilder before and after changes), you’ll get this event.
The object is the ParseObject which was updated. Its content is the latest value of the ParseObject.</p>
<pre class="language-dart"><code class="language-dart">subscription.on(LiveQueryEvent.update, (value) {
    print('*** UPDATE ***: ${DateTime.now().toString()}\n $value ');
    print((value as ParseObject).objectId);
    print((value as ParseObject).updatedAt);
    print((value as ParseObject).createdAt);
    print((value as ParseObject).get('objectId'));
    print((value as ParseObject).get('updatedAt'));
    print((value as ParseObject).get('createdAt'));
});
</code></pre>
<p><strong>Enter event</strong>
When an existing ParseObject’s old value does not fulfill the QueryBuilder but its new value fulfills the QueryBuilder,
you’ll get this event. The object is the ParseObject which enters the QueryBuilder.
Its content is the latest value of the ParseObject.</p>
<pre class="language-dart"><code class="language-dart">subscription.on(LiveQueryEvent.enter, (value) {
    print('*** ENTER ***: ${DateTime.now().toString()}\n $value ');
    print((value as ParseObject).objectId);
    print((value as ParseObject).updatedAt);
    print((value as ParseObject).createdAt);
    print((value as ParseObject).get('objectId'));
    print((value as ParseObject).get('updatedAt'));
    print((value as ParseObject).get('createdAt'));
});
</code></pre>
<p><strong>Leave event</strong>
When an existing ParseObject’s old value fulfills the QueryBuilder but its new value doesn’t fulfill the QueryBuilder,
you’ll get this event. The object is the ParseObject which leaves the QueryBuilder.
Its content is the latest value of the ParseObject.</p>
<pre class="language-dart"><code class="language-dart">subscription.on(LiveQueryEvent.leave, (value) {
    print('*** LEAVE ***: ${DateTime.now().toString()}\n $value ');
    print((value as ParseObject).objectId);
    print((value as ParseObject).updatedAt);
    print((value as ParseObject).createdAt);
    print((value as ParseObject).get('objectId'));
    print((value as ParseObject).get('updatedAt'));
    print((value as ParseObject).get('createdAt'));
});
</code></pre>
<p><strong>Delete event</strong>
When an existing ParseObject which fulfills the QueryBuilder is deleted, you’ll get this event.
The object is the ParseObject which is deleted</p>
<pre class="language-dart"><code class="language-dart">subscription.on(LiveQueryEvent.delete, (value) {
    print('*** DELETE ***: ${DateTime.now().toString()}\n $value ');
    print((value as ParseObject).objectId);
    print((value as ParseObject).updatedAt);
    print((value as ParseObject).createdAt);
    print((value as ParseObject).get('objectId'));
    print((value as ParseObject).get('updatedAt'));
    print((value as ParseObject).get('createdAt'));
});
</code></pre>
<p><strong>Unsubscribe</strong>
If you would like to stop receiving events from a QueryBuilder, you can just unsubscribe the subscription.
After that, you won’t get any events from the subscription object and will close the WebSocket connection to the
LiveQuery server.</p>
<pre class="language-dart"><code class="language-dart">liveQuery.client.unSubscribe(subscription);
</code></pre>
<p><strong>Disconnection</strong>
In case the client's connection to the server breaks,
LiveQuery will automatically try to reconnect.
LiveQuery will wait at increasing intervals between reconnection attempts.
By default, these intervals are set to <code>[0, 500, 1000, 2000, 5000, 10000]</code> for mobile and <code>[0, 500, 1000, 2000, 5000]</code> for web.
You can change these by providing a custom list using the <code>liveListRetryIntervals</code> parameter at <code>Parse.initialize()</code> ("-1" means "do not try to reconnect").</p>
<h2 id="parselivelist">ParseLiveList</h2>
<p>ParseLiveList makes implementing a dynamic List as simple as possible.</p>
<h3 id="general-use">General Use</h3>
<p>It ships with the ParseLiveList class itself, this class manages all elements of the list, sorts them,
keeps itself up to date and Notifies you on changes.</p>
<h3 id="included-sub-objects">Included Sub-Objects</h3>
<p>By default, ParseLiveQuery will provide you with all the objects you included in your Query like this:</p>
<pre class="language-dart"><code class="language-dart">queryBuilder.includeObject(/*List of all the included sub-objects*/);
</code></pre>
<p>ParseLiveList will not listen for updates on this objects by default.
To activate listening for updates on all included objects, add <code>listenOnAllSubItems: true</code> to your ParseLiveListWidgets constructor.
If you want ParseLiveList to listen for updates on only some sub-objects, use <code>listeningIncludes: const &lt;String&gt;[/*all the included sub-objects*/]</code> instead.
Just as QueryBuilder, ParseLiveList supports nested sub-objects too.</p>
<p><strong>NOTE:</strong> To use this features you have to enable <a href="#live-queries">Live Queries</a> first.</p>
<h2 id="users">Users</h2>
<p>You can create and control users just as normal using this SDK.</p>
<p>To register a user, first create one :</p>
<pre class="language-dart"><code class="language-dart">var user =  ParseUser().create("TestFlutter", "TestPassword123", "TestFlutterSDK@gmail.com");
</code></pre>
<p>Then have the user sign up:</p>
<pre class="language-dart"><code class="language-dart">var response = await user.signUp();
if (response.success) user = response.result;
</code></pre>
<p>You can also login with the user:</p>
<pre class="language-dart"><code class="language-dart">var response = await user.login();
if (response.success) user = response.result;
</code></pre>
<p>You can also logout with the user:</p>
<pre class="language-dart"><code class="language-dart">var response = await user.logout();
if (response.success) {
    print('User logout');
}
</code></pre>
<p>Also, once logged in you can manage sessions tokens. This feature can be called after Parse().init() on startup to check for a logged in user.</p>
<pre class="language-dart"><code class="language-dart">user = ParseUser.currentUser();
</code></pre>
<p>To add additional columns to the user:</p>
<pre class="language-dart"><code class="language-dart">var user = ParseUser("TestFlutter", "TestPassword123", "TestFlutterSDK@gmail.com")
            ..set("userLocation", "FlutterLand");
</code></pre>
<p>Other user features are:-</p>
<ul>
<li>Request Password Reset</li>
<li>Verification Email Request</li>
<li>Get all users</li>
<li>Save</li>
<li>Destroy user</li>
<li>Queries</li>
</ul>
<h2 id="facebook-oauth-and-3rd-party-loginuser">Facebook, OAuth and 3rd Party Login/User</h2>
<p>Usually, each provider will provide their own library for logins, but the loginWith method on ParseUser accepts a name of provider, then a Map&lt;String, dynamic&gt; with the authentication details required.
For Facebook and the example below, we used the library provided at <a href="https://pub.dev/packages/flutter_facebook_login">https://pub.dev/packages/flutter_facebook_login</a></p>
<pre class="language-dart"><code>Future&lt;void&gt; goToFacebookLogin() async {
       final FacebookLogin facebookLogin = FacebookLogin();
       final FacebookLoginResult result = await facebookLogin.logInWithReadPermissions(['email']);
   
       switch (result.status) {
         case FacebookLoginStatus.loggedIn:
           final ParseResponse response = await ParseUser.loginWith(
               'facebook',
               facebook(result.accessToken.token,
                   result.accessToken.userId,
                   result.accessToken.expires));
   
           if (response.success) {
             // User is logged in, test with ParseUser.currentUser()
           }
           break;
         case FacebookLoginStatus.cancelledByUser:
               // User cancelled
           break;
         case FacebookLoginStatus.error:
               // Error
           break;
       }
     }
</code></pre>
<p>For Google and the example below, we used the library provided at <a href="https://pub.dev/packages/google_sign_in">https://pub.dev/packages/google_sign_in</a></p>
<pre class="language-dart"><code>class OAuthLogin {
  final GoogleSignIn _googleSignIn = GoogleSignIn( scopes: ['email', 'https://www.googleapis.com/auth/contacts.readonly'] );
  
  sigInGoogle() async {
    GoogleSignInAccount account = await _googleSignIn.signIn();
    GoogleSignInAuthentication authentication = await account.authentication;
    await ParseUser.loginWith(
        'google',
        google(_googleSignIn.currentUser.id, 
               authentication.accessToken, 
               authentication.idToken));
  }
}
</code></pre>
<h2 id="security-for-objects---parseacl">Security for Objects - ParseACL</h2>
<p>For any object, you can specify which users are allowed to read the object, and which users are allowed to modify an object.
To support this type of security, each object has an access control list, implemented by the <strong>ParseACL</strong> class.</p>
<p>If ParseACL is not specified (with the exception of the ParseUser class) all objects are set to Public for read and write.
The simplest way to use a ParseACL is to specify that an object may only be read or written by a single user.
To create such an object, there must first be a logged in ParseUser. Then, new ParseACL(user) generates a ParseACL that
limits access to that user. An object’s ACL is updated when the object is saved, like any other property.</p>
<pre class="language-dart"><code class="language-dart">ParseUser user = await ParseUser.currentUser() as ParseUser;
ParseACL parseACL = ParseACL(owner: user);
  
ParseObject parseObject = ParseObject("TestAPI");
...
parseObject.setACL(parseACL);
var apiResponse = await parseObject.save();
</code></pre>
<p>Permissions can also be granted on a per-user basis. You can add permissions individually to a ParseACL using
<strong>setReadAccess</strong> and <strong>setWriteAccess</strong></p>
<pre class="language-dart"><code class="language-dart">ParseUser user = await ParseUser.currentUser() as ParseUser;
ParseACL parseACL = ParseACL();
//grant total access to current user
parseACL.setReadAccess(userId: user.objectId, allowed: true);
parseACL.setWriteAccess(userId: user.objectId, allowed: true);
//grant read access to userId: 'TjRuDjuSAO' 
parseACL.setReadAccess(userId: 'TjRuDjuSAO', allowed: true);
parseACL.setWriteAccess(userId: 'TjRuDjuSAO', allowed: false);

ParseObject parseObject = ParseObject("TestAPI");
...
parseObject.setACL(parseACL);
var apiResponse = await parseObject.save();
</code></pre>
<p>You can also grant permissions to all users at once using setPublicReadAccess and setPublicWriteAccess.</p>
<pre class="language-dart"><code class="language-dart">ParseACL parseACL = ParseACL();
parseACL.setPublicReadAccess(allowed: true);
parseACL.setPublicWriteAccess(allowed: true);

ParseObject parseObject = ParseObject("TestAPI");
...  
parseObject.setACL(parseACL);
var apiResponse = await parseObject.save();
</code></pre>
<p>Operations that are forbidden, such as deleting an object that you do not have write access to, result in a
ParseError with code 101: 'ObjectNotFound'.
For security purposes, this prevents clients from distinguishing which object ids exist but are secured, versus which
object ids do not exist at all.</p>
<p>You can retrieve the ACL list of an object using:</p>
<pre class="language-dart"><code class="language-dart">ParseACL parseACL = parseObject.getACL();
</code></pre>
<p>To set the ACL to <code>ParseRole</code> use:</p>
<pre class="language-dart"><code class="language-dart">parseACL.setReadAccess(userId: "role:ROLE_NAME", allowed: true);
parseACL.setWriteAccess(userId: "role:ROLE_NAME", allowed: true);

</code></pre>
<h2 id="config">Config</h2>
<p>The SDK supports Parse Config. A map of all configs can be grabbed from the server by calling :</p>
<pre class="language-dart"><code class="language-dart">var response = await ParseConfig().getConfigs();
</code></pre>
<p>and to add a config:</p>
<pre class="language-dart"><code class="language-dart">ParseConfig().addConfig('TestConfig', 'testing');
</code></pre>
<h2 id="cloud-functions">Cloud Functions</h2>
<p>The SDK supports call Cloud Functions.</p>
<p>Executes a cloud function that returns a ParseObject type</p>
<pre class="language-dart"><code class="language-dart">final ParseCloudFunction function = ParseCloudFunction('hello');
final ParseResponse result =
    await function.executeObjectFunction&lt;ParseObject&gt;();
if (result.success) {
  if (result.result is ParseObject) {
    final ParseObject parseObject = result.result;
    print(parseObject.className);
  }
}
</code></pre>
<p>Executes a cloud function with parameters</p>
<pre class="language-dart"><code class="language-dart">final ParseCloudFunction function = ParseCloudFunction('hello');
final Map&lt;String, String&gt; params = &lt;String, String&gt;{'plan': 'paid'};
function.execute(parameters: params);
</code></pre>
<h2 id="relation">Relation</h2>
<p>The SDK supports Relation.</p>
<p>To add relation to object:</p>
<pre class="language-dart"><code class="language-dart">dietPlan.addRelation('fruits', [ParseObject("Fruits")..set("objectId", "XGadzYxnac")]);
</code></pre>
<p>To remove relation to object:</p>
<pre class="language-dart"><code class="language-dart">dietPlan.removeRelation('fruits', [ParseObject("Fruits")..set("objectId", "XGadzYxnac")]);
</code></pre>
<p>To Retrive a relation instance for user, call:</p>
<pre class="language-dart"><code class="language-dart">final relation = dietPlan.getRelation('fruits');
</code></pre>
<p>and then you can add a relation to the passed in object:</p>
<pre class="language-dart"><code>relation.add(dietPlan);
final result = await user.save();
</code></pre>
<p>To retrieve objects that are members of Relation field of a parent object:</p>
<pre class="language-dart"><code class="language-dart">QueryBuilder&lt;ParseObject&gt; query =
    QueryBuilder&lt;ParseObject&gt;(ParseObject('Fruits'))
      ..whereRelatedTo('fruits', 'DietPlan', DietPlan.objectId);
</code></pre>
<h2 id="file">File</h2>
<p>There are three different file classes in this SDK:</p>
<ul>
<li><code>ParseFileBase</code> is and abstract class and is the foundation of every file class that can be handled by this SDK.</li>
<li><code>ParseFile</code> (former the only file class in the SDK) extends ParseFileBase and is by default used as the file class on every platform but web.
This class uses a <code>File</code> from <code>dart:io</code> for storing the raw file.</li>
<li><code>ParseWebFile</code> is the equivalent to ParseFile used at Flutter Web.
This class uses an <code>Uint8List</code> for storing the raw file.</li>
</ul>
<p>These classes are used by default to represent files, but you can also build your own class extending ParseFileBase and provide a custom <code>ParseFileConstructor</code> similar to the <code>SubClasses</code>.</p>
<p>Have a look at the example application for a small (non web) example.</p>
<p>When uploading or downloading a file, you can use the <code>progressCallback</code>-parameter to track the progress of the http request.</p>
<pre class="language-dart"><code class="language-dart">//A short example for showing an image from a ParseFileBase
Widget buildImage(ParseFileBase image){
  return FutureBuilder&lt;ParseFileBase&gt;(
    future: image.download(),
    builder: (BuildContext context,
    AsyncSnapshot&lt;ParseFileBase&gt; snapshot) {
      if (snapshot.hasData) {
        if (kIsWeb) {
          return Image.memory((snapshot.data as ParseWebFile).file);
        } else {
          return Image.file((snapshot.data as ParseFile).file);
        }
      } else {
        return CircularProgressIndicator();
      }
    },
  );
}
</code></pre>
<pre class="language-dart"><code class="language-dart">//A short example for storing a selected picture
//libraries: image_picker (https://pub.dev/packages/image_picker), image_picker_for_web (https://pub.dev/packages/image_picker_for_web)
PickedFile pickedFile = await ImagePicker().getImage(source: ImageSource.gallery);
ParseFileBase parseFile;
if (kIsWeb) {
  //Seems weird, but this lets you get the data from the selected file as an Uint8List very easily. 
  ParseWebFile file = ParseWebFile(null, name: null, url: pickedFile.path);
  await file.download();
  parseFile = ParseWebFile(file.file, name: file.name);
} else {
  parseFile = ParseFile(File(pickedFile.path));
}
someParseObject.set("image", parseFile);
//This saves the ParseObject as well as all of its children, and the ParseFileBase is such a child. 
await someParseObject.save();
</code></pre>
<pre class="language-dart"><code class="language-dart">//progressCallback example
file.upload(progressCallback: (int count, int total) =&gt; print("$count of $total"));
</code></pre>
<h2 id="other-features">Other Features</h2>
<p>Main:</p>
<ul>
<li>Installation (View the example application)</li>
<li>GeoPoints (View the example application)</li>
<li>Persistent storage</li>
<li>Debug Mode - Logging API calls</li>
<li>Manage Session ID's tokens</li>
</ul>
<p>User:</p>
<ul>
<li>Queries</li>
<li>Anonymous (View the example application)</li>
<li>3rd Party Authentication</li>
</ul>
<p>Objects:</p>
<ul>
<li>Create new object</li>
<li>Extend Parse Object and create local objects that can be saved and retreived</li>
<li>Queries</li>
</ul>
</section>


      <section class="summary">
          <h2>Libraries</h2>
        <dl>
          <dt id="flutter_parse_sdk">
  <span class="name"><a href="flutter_parse_sdk/flutter_parse_sdk-library.html">flutter_parse_sdk</a></span> 

</dt>
<dd>
</dd>

        </dl>
      </section>

  </div> <!-- /.main-content -->

  <div id="dartdoc-sidebar-left" class="sidebar sidebar-offcanvas-left">
    <header id="header-search-sidebar" class="hidden-l">
  <form class="search-sidebar" role="search">
    <input type="text" id="search-sidebar" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>

<ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
  <li><a href="https://github.com/parse-community/Parse-SDK-Flutter">parse_server_sdk package</a></li>
</ol>


    <h5 class="hidden-xs"><span class="package-name">parse_server_sdk</span> <span class="package-kind">package</span></h5>
    <ol>
      <li class="section-title">Libraries</li>
      <li><a href="flutter_parse_sdk/flutter_parse_sdk-library.html">flutter_parse_sdk</a></li>
</ol>

  </div>

  <div id="dartdoc-sidebar-right" class="sidebar sidebar-offcanvas-right">
  </div>

</main>

<footer>
  <span class="no-break">
    parse_server_sdk
      5.1.1
  </span>

  
</footer>



<script src="static-assets/highlight.pack.js?v1"></script>
<script src="static-assets/docs.dart.js"></script>



</body>

</html>

